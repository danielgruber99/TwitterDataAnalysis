<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.twitterclient API documentation</title>
<meta name="description" content="Twitterclient module for connecting to the Twitter API Endpoint.
Client is used for fetching tweets, users, followers and tweets of followers." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.twitterclient</code></h1>
</header>
<section id="section-intro">
<p>Twitterclient module for connecting to the Twitter API Endpoint.
Client is used for fetching tweets, users, followers and tweets of followers.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Twitterclient module for connecting to the Twitter API Endpoint.
Client is used for fetching tweets, users, followers and tweets of followers.
&#34;&#34;&#34;
import os
import tweepy
import pandas as pd
import src.constants as const


class TwitterClient:
    &#34;&#34;&#34;
    This class is used to firstly create a connection to the Twitter API v2 Endpoint by authenticating
    with required tokens. After the successful creation of the client connection it provides several
    methods to fetch tweets, users, followers and the tweets of followers.

    Attributes
    ----------
    client : tweepy.Client
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Authenticate to the twitter API v2 endpoint.
        &#34;&#34;&#34;
        self.client = None
        self.authenticate()

    def authenticate(self):
        &#34;&#34;&#34;
        Authenticate to twitter API v2 endpoint by setting the member variable client.
        &#34;&#34;&#34;
        bearer_token = os.environ.get(&#34;TWITTER_BEARER_TOKEN&#34;)
        # logon to api v2 endpoint
        try:
            self.client = tweepy.Client(bearer_token=bearer_token)
        except:
            self.client = None
            print(&#34;Error: Authentication Failed!&#34;)

    def fetch_tweets(self, querystring) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch Tweets for given querystring where only tweets in language english with at least one hashtag are considered. Retweets are excluded.

        Parameters
        ----------
        querystring : str
            the topic (querystring) for which tweets is searched to fetch

        Returns
        -------
        tweets_df : pd.DataFrame or None
            Contains fetched tweets, or None if an error/exception occured.
        &#34;&#34;&#34;
        tweets_df = None
        if self.client:
            try:
                response = self.client.search_recent_tweets(
                    query=f&#34;{querystring} lang:en -is:retweet has:hashtags&#34;,
                    tweet_fields=[&#34;created_at&#34;, &#34;lang&#34;, &#34;entities&#34;],
                    expansions=[&#34;author_id&#34;],
                    max_results=const.NR_TWEETS,
                )
                columns = [
                    const.tweet_id,
                    const.tweet_text,
                    const.tweet_hashtags,
                    const.tweet_createdAt,
                    const.user_id,
                ]
                data = []
                for tweet in response.data:
                    hashtags = self.extract_hashtags(tweet)
                    data.append(
                        [
                            tweet.id,
                            tweet.text,
                            hashtags,
                            tweet.created_at,
                            tweet.author_id,
                        ]
                    )
                    tweets_df = pd.DataFrame(data, columns=columns)
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        return tweets_df

    def fetch_users(self, userids) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch User IDs, names and usernames of given userids in previously fetched set of Tweets.
        Required for providing the user the possibility to browse through all users.

        Parameters
        ----------
        userids : list
            userids to look up the name and username for

        Returns
        -------
        users_df : pd.DataFrame or None
            Contains fetched users, or None if an error/exception occured.
        &#34;&#34;&#34;
        columns = [const.user_id, const.user_name, const.user_username]
        data = []
        if self.client:
            for userid in userids:
                try:
                    response = self.client.get_user(
                        id=userid, user_fields=[&#34;id&#34;, &#34;name&#34;, &#34;username&#34;]
                    )
                    user = response.data
                    # handle if for user no data could be fetched but also no error was trown by the Twitter API
                    if user:
                        data.append([user.id, user.name, user.username])
                except tweepy.errors.Unauthorized as unauthorized:
                    print(&#34;Unauthorized:&#34;, unauthorized)
                    print(
                        &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                    )
                    return None
                except tweepy.errors.TooManyRequests as toomanyrequests:
                    print(&#34;TooManyRequests:&#34;, toomanyrequests)
                    print(
                        &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                    )
                    return None
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
            return None
        users_df = pd.DataFrame(data, columns=columns)
        return users_df

    def extract_hashtags(self, tweet) -&gt; list:
        &#34;&#34;&#34;
        Extract hashtags from retrieved response.data dictionary.

        Parameters
        ----------
        tweet : str
            userids to look up the name and username for

        Returns
        -------
        hashtags_string : str
            string of all hashtags separated by commas (for later splitting again)
        &#34;&#34;&#34;
        entity_hashtag = tweet.entities[&#34;hashtags&#34;]
        hashtags = []
        for hashtag in entity_hashtag:
            hashtags.append(hashtag[&#34;tag&#34;])
        hashtags_string = &#34;,&#34;.join(hashtags)
        return hashtags_string

    def fetch_followers(self, userid) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch followers for a given user ID.

        Parameters
        ----------
        userid : int
            given userid to fetch followers for

        Returns
        -------
        followers_df : pd.DataFrame or None
            Contains fetched followers, or None if an error/exception occured.
        &#34;&#34;&#34;
        followers_df = None
        if self.client:
            try:
                response_followers = self.client.get_users_followers(
                    userid,
                    user_fields=[
                        &#34;created_at&#34;,
                        &#34;description&#34;,
                        &#34;entities&#34;,
                        &#34;id&#34;,
                        &#34;location&#34;,
                        &#34;name&#34;,
                        &#34;profile_image_url&#34;,
                        &#34;public_metrics&#34;,
                        &#34;url&#34;,
                        &#34;username&#34;,
                    ],
                    max_results=const.NR_FOLLOWERS,
                )
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
            else:
                followers = response_followers.data
                columns = [
                    const.follower_id,
                    const.follower_name,
                    const.follower_username,
                    const.follower_bio,
                    const.follower_location,
                    const.follower_url,
                    const.follower_created_at,
                    const.follower_following,
                    const.follower_followers,
                    const.follower_profile_image_url,
                ]  # description in user is better known as bio (profile of user)
                data = []
                if followers:
                    for follower in followers:
                        data.append(
                            [
                                follower.id,
                                follower.name,
                                follower.username,
                                follower.description,
                                follower.location,
                                follower.url,
                                follower.created_at,
                                follower.public_metrics.get(&#34;following_count&#34;),
                                follower.public_metrics.get(&#34;followers_count&#34;),
                                follower.profile_image_url,
                            ]
                        )
                    followers_df = pd.DataFrame(data, columns=columns)
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        return followers_df

    def fetch_tweets_of_followers(self, followerids) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch tweets of given followers.

        Parameters
        ----------
        followerids : list
            Followerids to fetch tweets for.

        Returns
        -------
        followers_tweets_df : pd.DataFrame or None
            Contains fetched tweets for given list of followerids, or None if an error/exception occured.
        &#34;&#34;&#34;
        columns = [
            const.follower_id,
            const.follower_tweet_id,
            const.follower_tweet_text,
        ]
        data = []
        if self.client:
            for followerid in followerids:
                try:
                    response = self.client.get_users_tweets(
                        followerid, max_results=const.NR_FOLLOWERS_TWEETS
                    )
                except tweepy.errors.Unauthorized as unauthorized:
                    print(&#34;Unauthorized:&#34;, unauthorized)
                    print(
                        &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                    )
                    return None
                except tweepy.errors.TooManyRequests as toomanyrequests:
                    print(&#34;TooManyRequests:&#34;, toomanyrequests)
                    print(
                        &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                    )
                    return None
                else:
                    tweets_of_followers = response.data
                    if tweets_of_followers is not None:
                        for follower_tweet in tweets_of_followers:
                            data.append(
                                [followerid, follower_tweet.id, follower_tweet.text]
                            )
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        followers_tweets_df = pd.DataFrame(data, columns=columns)
        return followers_tweets_df

    def lookup_user(self, userid) -&gt; str:
        &#34;&#34;&#34;
        Lookup username for given user ID.

        Parameters
        ----------
        userid : int
            userid to lookup corresponding username.

        Returns
        -------
        user.username : str or None
            Contains username of given userid, or None if an error/exception occured.
        &#34;&#34;&#34;
        if self.client:
            try:
                response = self.client.get_user(
                    id=userid, user_fields=[&#34;name&#34;, &#34;username&#34;]
                )
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
            else:
                user = response.data
                if user:
                    return user.username
        else:
            return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.twitterclient.TwitterClient"><code class="flex name class">
<span>class <span class="ident">TwitterClient</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to firstly create a connection to the Twitter API v2 Endpoint by authenticating
with required tokens. After the successful creation of the client connection it provides several
methods to fetch tweets, users, followers and the tweets of followers.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>tweepy.Client</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Authenticate to the twitter API v2 endpoint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TwitterClient:
    &#34;&#34;&#34;
    This class is used to firstly create a connection to the Twitter API v2 Endpoint by authenticating
    with required tokens. After the successful creation of the client connection it provides several
    methods to fetch tweets, users, followers and the tweets of followers.

    Attributes
    ----------
    client : tweepy.Client
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Authenticate to the twitter API v2 endpoint.
        &#34;&#34;&#34;
        self.client = None
        self.authenticate()

    def authenticate(self):
        &#34;&#34;&#34;
        Authenticate to twitter API v2 endpoint by setting the member variable client.
        &#34;&#34;&#34;
        bearer_token = os.environ.get(&#34;TWITTER_BEARER_TOKEN&#34;)
        # logon to api v2 endpoint
        try:
            self.client = tweepy.Client(bearer_token=bearer_token)
        except:
            self.client = None
            print(&#34;Error: Authentication Failed!&#34;)

    def fetch_tweets(self, querystring) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch Tweets for given querystring where only tweets in language english with at least one hashtag are considered. Retweets are excluded.

        Parameters
        ----------
        querystring : str
            the topic (querystring) for which tweets is searched to fetch

        Returns
        -------
        tweets_df : pd.DataFrame or None
            Contains fetched tweets, or None if an error/exception occured.
        &#34;&#34;&#34;
        tweets_df = None
        if self.client:
            try:
                response = self.client.search_recent_tweets(
                    query=f&#34;{querystring} lang:en -is:retweet has:hashtags&#34;,
                    tweet_fields=[&#34;created_at&#34;, &#34;lang&#34;, &#34;entities&#34;],
                    expansions=[&#34;author_id&#34;],
                    max_results=const.NR_TWEETS,
                )
                columns = [
                    const.tweet_id,
                    const.tweet_text,
                    const.tweet_hashtags,
                    const.tweet_createdAt,
                    const.user_id,
                ]
                data = []
                for tweet in response.data:
                    hashtags = self.extract_hashtags(tweet)
                    data.append(
                        [
                            tweet.id,
                            tweet.text,
                            hashtags,
                            tweet.created_at,
                            tweet.author_id,
                        ]
                    )
                    tweets_df = pd.DataFrame(data, columns=columns)
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        return tweets_df

    def fetch_users(self, userids) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch User IDs, names and usernames of given userids in previously fetched set of Tweets.
        Required for providing the user the possibility to browse through all users.

        Parameters
        ----------
        userids : list
            userids to look up the name and username for

        Returns
        -------
        users_df : pd.DataFrame or None
            Contains fetched users, or None if an error/exception occured.
        &#34;&#34;&#34;
        columns = [const.user_id, const.user_name, const.user_username]
        data = []
        if self.client:
            for userid in userids:
                try:
                    response = self.client.get_user(
                        id=userid, user_fields=[&#34;id&#34;, &#34;name&#34;, &#34;username&#34;]
                    )
                    user = response.data
                    # handle if for user no data could be fetched but also no error was trown by the Twitter API
                    if user:
                        data.append([user.id, user.name, user.username])
                except tweepy.errors.Unauthorized as unauthorized:
                    print(&#34;Unauthorized:&#34;, unauthorized)
                    print(
                        &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                    )
                    return None
                except tweepy.errors.TooManyRequests as toomanyrequests:
                    print(&#34;TooManyRequests:&#34;, toomanyrequests)
                    print(
                        &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                    )
                    return None
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
            return None
        users_df = pd.DataFrame(data, columns=columns)
        return users_df

    def extract_hashtags(self, tweet) -&gt; list:
        &#34;&#34;&#34;
        Extract hashtags from retrieved response.data dictionary.

        Parameters
        ----------
        tweet : str
            userids to look up the name and username for

        Returns
        -------
        hashtags_string : str
            string of all hashtags separated by commas (for later splitting again)
        &#34;&#34;&#34;
        entity_hashtag = tweet.entities[&#34;hashtags&#34;]
        hashtags = []
        for hashtag in entity_hashtag:
            hashtags.append(hashtag[&#34;tag&#34;])
        hashtags_string = &#34;,&#34;.join(hashtags)
        return hashtags_string

    def fetch_followers(self, userid) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch followers for a given user ID.

        Parameters
        ----------
        userid : int
            given userid to fetch followers for

        Returns
        -------
        followers_df : pd.DataFrame or None
            Contains fetched followers, or None if an error/exception occured.
        &#34;&#34;&#34;
        followers_df = None
        if self.client:
            try:
                response_followers = self.client.get_users_followers(
                    userid,
                    user_fields=[
                        &#34;created_at&#34;,
                        &#34;description&#34;,
                        &#34;entities&#34;,
                        &#34;id&#34;,
                        &#34;location&#34;,
                        &#34;name&#34;,
                        &#34;profile_image_url&#34;,
                        &#34;public_metrics&#34;,
                        &#34;url&#34;,
                        &#34;username&#34;,
                    ],
                    max_results=const.NR_FOLLOWERS,
                )
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
            else:
                followers = response_followers.data
                columns = [
                    const.follower_id,
                    const.follower_name,
                    const.follower_username,
                    const.follower_bio,
                    const.follower_location,
                    const.follower_url,
                    const.follower_created_at,
                    const.follower_following,
                    const.follower_followers,
                    const.follower_profile_image_url,
                ]  # description in user is better known as bio (profile of user)
                data = []
                if followers:
                    for follower in followers:
                        data.append(
                            [
                                follower.id,
                                follower.name,
                                follower.username,
                                follower.description,
                                follower.location,
                                follower.url,
                                follower.created_at,
                                follower.public_metrics.get(&#34;following_count&#34;),
                                follower.public_metrics.get(&#34;followers_count&#34;),
                                follower.profile_image_url,
                            ]
                        )
                    followers_df = pd.DataFrame(data, columns=columns)
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        return followers_df

    def fetch_tweets_of_followers(self, followerids) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Fetch tweets of given followers.

        Parameters
        ----------
        followerids : list
            Followerids to fetch tweets for.

        Returns
        -------
        followers_tweets_df : pd.DataFrame or None
            Contains fetched tweets for given list of followerids, or None if an error/exception occured.
        &#34;&#34;&#34;
        columns = [
            const.follower_id,
            const.follower_tweet_id,
            const.follower_tweet_text,
        ]
        data = []
        if self.client:
            for followerid in followerids:
                try:
                    response = self.client.get_users_tweets(
                        followerid, max_results=const.NR_FOLLOWERS_TWEETS
                    )
                except tweepy.errors.Unauthorized as unauthorized:
                    print(&#34;Unauthorized:&#34;, unauthorized)
                    print(
                        &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                    )
                    return None
                except tweepy.errors.TooManyRequests as toomanyrequests:
                    print(&#34;TooManyRequests:&#34;, toomanyrequests)
                    print(
                        &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                    )
                    return None
                else:
                    tweets_of_followers = response.data
                    if tweets_of_followers is not None:
                        for follower_tweet in tweets_of_followers:
                            data.append(
                                [followerid, follower_tweet.id, follower_tweet.text]
                            )
        else:
            print(
                &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        followers_tweets_df = pd.DataFrame(data, columns=columns)
        return followers_tweets_df

    def lookup_user(self, userid) -&gt; str:
        &#34;&#34;&#34;
        Lookup username for given user ID.

        Parameters
        ----------
        userid : int
            userid to lookup corresponding username.

        Returns
        -------
        user.username : str or None
            Contains username of given userid, or None if an error/exception occured.
        &#34;&#34;&#34;
        if self.client:
            try:
                response = self.client.get_user(
                    id=userid, user_fields=[&#34;name&#34;, &#34;username&#34;]
                )
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
            else:
                user = response.data
                if user:
                    return user.username
        else:
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.twitterclient.TwitterClient.authenticate"><code class="name flex">
<span>def <span class="ident">authenticate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Authenticate to twitter API v2 endpoint by setting the member variable client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate(self):
    &#34;&#34;&#34;
    Authenticate to twitter API v2 endpoint by setting the member variable client.
    &#34;&#34;&#34;
    bearer_token = os.environ.get(&#34;TWITTER_BEARER_TOKEN&#34;)
    # logon to api v2 endpoint
    try:
        self.client = tweepy.Client(bearer_token=bearer_token)
    except:
        self.client = None
        print(&#34;Error: Authentication Failed!&#34;)</code></pre>
</details>
</dd>
<dt id="src.twitterclient.TwitterClient.extract_hashtags"><code class="name flex">
<span>def <span class="ident">extract_hashtags</span></span>(<span>self, tweet) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Extract hashtags from retrieved response.data dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tweet</code></strong> :&ensp;<code>str</code></dt>
<dd>userids to look up the name and username for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hashtags_string</code></strong> :&ensp;<code>str</code></dt>
<dd>string of all hashtags separated by commas (for later splitting again)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_hashtags(self, tweet) -&gt; list:
    &#34;&#34;&#34;
    Extract hashtags from retrieved response.data dictionary.

    Parameters
    ----------
    tweet : str
        userids to look up the name and username for

    Returns
    -------
    hashtags_string : str
        string of all hashtags separated by commas (for later splitting again)
    &#34;&#34;&#34;
    entity_hashtag = tweet.entities[&#34;hashtags&#34;]
    hashtags = []
    for hashtag in entity_hashtag:
        hashtags.append(hashtag[&#34;tag&#34;])
    hashtags_string = &#34;,&#34;.join(hashtags)
    return hashtags_string</code></pre>
</details>
</dd>
<dt id="src.twitterclient.TwitterClient.fetch_followers"><code class="name flex">
<span>def <span class="ident">fetch_followers</span></span>(<span>self, userid) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch followers for a given user ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userid</code></strong> :&ensp;<code>int</code></dt>
<dd>given userid to fetch followers for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>followers_df</code></strong> :&ensp;<code>pd.DataFrame</code> or <code>None</code></dt>
<dd>Contains fetched followers, or None if an error/exception occured.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_followers(self, userid) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Fetch followers for a given user ID.

    Parameters
    ----------
    userid : int
        given userid to fetch followers for

    Returns
    -------
    followers_df : pd.DataFrame or None
        Contains fetched followers, or None if an error/exception occured.
    &#34;&#34;&#34;
    followers_df = None
    if self.client:
        try:
            response_followers = self.client.get_users_followers(
                userid,
                user_fields=[
                    &#34;created_at&#34;,
                    &#34;description&#34;,
                    &#34;entities&#34;,
                    &#34;id&#34;,
                    &#34;location&#34;,
                    &#34;name&#34;,
                    &#34;profile_image_url&#34;,
                    &#34;public_metrics&#34;,
                    &#34;url&#34;,
                    &#34;username&#34;,
                ],
                max_results=const.NR_FOLLOWERS,
            )
        except tweepy.errors.Unauthorized as unauthorized:
            print(&#34;Unauthorized:&#34;, unauthorized)
            print(
                &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        except tweepy.errors.TooManyRequests as toomanyrequests:
            print(&#34;TooManyRequests:&#34;, toomanyrequests)
            print(
                &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
            )
        else:
            followers = response_followers.data
            columns = [
                const.follower_id,
                const.follower_name,
                const.follower_username,
                const.follower_bio,
                const.follower_location,
                const.follower_url,
                const.follower_created_at,
                const.follower_following,
                const.follower_followers,
                const.follower_profile_image_url,
            ]  # description in user is better known as bio (profile of user)
            data = []
            if followers:
                for follower in followers:
                    data.append(
                        [
                            follower.id,
                            follower.name,
                            follower.username,
                            follower.description,
                            follower.location,
                            follower.url,
                            follower.created_at,
                            follower.public_metrics.get(&#34;following_count&#34;),
                            follower.public_metrics.get(&#34;followers_count&#34;),
                            follower.profile_image_url,
                        ]
                    )
                followers_df = pd.DataFrame(data, columns=columns)
    else:
        print(
            &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
        )
    return followers_df</code></pre>
</details>
</dd>
<dt id="src.twitterclient.TwitterClient.fetch_tweets"><code class="name flex">
<span>def <span class="ident">fetch_tweets</span></span>(<span>self, querystring) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch Tweets for given querystring where only tweets in language english with at least one hashtag are considered. Retweets are excluded.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>querystring</code></strong> :&ensp;<code>str</code></dt>
<dd>the topic (querystring) for which tweets is searched to fetch</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tweets_df</code></strong> :&ensp;<code>pd.DataFrame</code> or <code>None</code></dt>
<dd>Contains fetched tweets, or None if an error/exception occured.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_tweets(self, querystring) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Fetch Tweets for given querystring where only tweets in language english with at least one hashtag are considered. Retweets are excluded.

    Parameters
    ----------
    querystring : str
        the topic (querystring) for which tweets is searched to fetch

    Returns
    -------
    tweets_df : pd.DataFrame or None
        Contains fetched tweets, or None if an error/exception occured.
    &#34;&#34;&#34;
    tweets_df = None
    if self.client:
        try:
            response = self.client.search_recent_tweets(
                query=f&#34;{querystring} lang:en -is:retweet has:hashtags&#34;,
                tweet_fields=[&#34;created_at&#34;, &#34;lang&#34;, &#34;entities&#34;],
                expansions=[&#34;author_id&#34;],
                max_results=const.NR_TWEETS,
            )
            columns = [
                const.tweet_id,
                const.tweet_text,
                const.tweet_hashtags,
                const.tweet_createdAt,
                const.user_id,
            ]
            data = []
            for tweet in response.data:
                hashtags = self.extract_hashtags(tweet)
                data.append(
                    [
                        tweet.id,
                        tweet.text,
                        hashtags,
                        tweet.created_at,
                        tweet.author_id,
                    ]
                )
                tweets_df = pd.DataFrame(data, columns=columns)
        except tweepy.errors.Unauthorized as unauthorized:
            print(&#34;Unauthorized:&#34;, unauthorized)
            print(
                &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        except tweepy.errors.TooManyRequests as toomanyrequests:
            print(&#34;TooManyRequests:&#34;, toomanyrequests)
            print(
                &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
            )
    else:
        print(
            &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
        )
    return tweets_df</code></pre>
</details>
</dd>
<dt id="src.twitterclient.TwitterClient.fetch_tweets_of_followers"><code class="name flex">
<span>def <span class="ident">fetch_tweets_of_followers</span></span>(<span>self, followerids) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch tweets of given followers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>followerids</code></strong> :&ensp;<code>list</code></dt>
<dd>Followerids to fetch tweets for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>followers_tweets_df</code></strong> :&ensp;<code>pd.DataFrame</code> or <code>None</code></dt>
<dd>Contains fetched tweets for given list of followerids, or None if an error/exception occured.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_tweets_of_followers(self, followerids) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Fetch tweets of given followers.

    Parameters
    ----------
    followerids : list
        Followerids to fetch tweets for.

    Returns
    -------
    followers_tweets_df : pd.DataFrame or None
        Contains fetched tweets for given list of followerids, or None if an error/exception occured.
    &#34;&#34;&#34;
    columns = [
        const.follower_id,
        const.follower_tweet_id,
        const.follower_tweet_text,
    ]
    data = []
    if self.client:
        for followerid in followerids:
            try:
                response = self.client.get_users_tweets(
                    followerid, max_results=const.NR_FOLLOWERS_TWEETS
                )
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
                return None
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
                return None
            else:
                tweets_of_followers = response.data
                if tweets_of_followers is not None:
                    for follower_tweet in tweets_of_followers:
                        data.append(
                            [followerid, follower_tweet.id, follower_tweet.text]
                        )
    else:
        print(
            &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
        )
    followers_tweets_df = pd.DataFrame(data, columns=columns)
    return followers_tweets_df</code></pre>
</details>
</dd>
<dt id="src.twitterclient.TwitterClient.fetch_users"><code class="name flex">
<span>def <span class="ident">fetch_users</span></span>(<span>self, userids) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch User IDs, names and usernames of given userids in previously fetched set of Tweets.
Required for providing the user the possibility to browse through all users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userids</code></strong> :&ensp;<code>list</code></dt>
<dd>userids to look up the name and username for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users_df</code></strong> :&ensp;<code>pd.DataFrame</code> or <code>None</code></dt>
<dd>Contains fetched users, or None if an error/exception occured.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_users(self, userids) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Fetch User IDs, names and usernames of given userids in previously fetched set of Tweets.
    Required for providing the user the possibility to browse through all users.

    Parameters
    ----------
    userids : list
        userids to look up the name and username for

    Returns
    -------
    users_df : pd.DataFrame or None
        Contains fetched users, or None if an error/exception occured.
    &#34;&#34;&#34;
    columns = [const.user_id, const.user_name, const.user_username]
    data = []
    if self.client:
        for userid in userids:
            try:
                response = self.client.get_user(
                    id=userid, user_fields=[&#34;id&#34;, &#34;name&#34;, &#34;username&#34;]
                )
                user = response.data
                # handle if for user no data could be fetched but also no error was trown by the Twitter API
                if user:
                    data.append([user.id, user.name, user.username])
            except tweepy.errors.Unauthorized as unauthorized:
                print(&#34;Unauthorized:&#34;, unauthorized)
                print(
                    &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
                )
                return None
            except tweepy.errors.TooManyRequests as toomanyrequests:
                print(&#34;TooManyRequests:&#34;, toomanyrequests)
                print(
                    &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
                )
                return None
    else:
        print(
            &#34;The twitterclient couldn&#39;t be set up.\nEnsure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
        )
        return None
    users_df = pd.DataFrame(data, columns=columns)
    return users_df</code></pre>
</details>
</dd>
<dt id="src.twitterclient.TwitterClient.lookup_user"><code class="name flex">
<span>def <span class="ident">lookup_user</span></span>(<span>self, userid) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup username for given user ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userid</code></strong> :&ensp;<code>int</code></dt>
<dd>userid to lookup corresponding username.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>user.username : str</code> or <code>None</code></dt>
<dd>Contains username of given userid, or None if an error/exception occured.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup_user(self, userid) -&gt; str:
    &#34;&#34;&#34;
    Lookup username for given user ID.

    Parameters
    ----------
    userid : int
        userid to lookup corresponding username.

    Returns
    -------
    user.username : str or None
        Contains username of given userid, or None if an error/exception occured.
    &#34;&#34;&#34;
    if self.client:
        try:
            response = self.client.get_user(
                id=userid, user_fields=[&#34;name&#34;, &#34;username&#34;]
            )
        except tweepy.errors.Unauthorized as unauthorized:
            print(&#34;Unauthorized:&#34;, unauthorized)
            print(
                &#34;Authorization failed. Ensure you have provided valid Access/Consumer/Bearer Tokens and Secrets.&#34;
            )
        except tweepy.errors.TooManyRequests as toomanyrequests:
            print(&#34;TooManyRequests:&#34;, toomanyrequests)
            print(
                &#34;You have done too many requests. Try again in approximately 15 minutes.&#34;
            )
        else:
            user = response.data
            if user:
                return user.username
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.twitterclient.TwitterClient" href="#src.twitterclient.TwitterClient">TwitterClient</a></code></h4>
<ul class="">
<li><code><a title="src.twitterclient.TwitterClient.authenticate" href="#src.twitterclient.TwitterClient.authenticate">authenticate</a></code></li>
<li><code><a title="src.twitterclient.TwitterClient.extract_hashtags" href="#src.twitterclient.TwitterClient.extract_hashtags">extract_hashtags</a></code></li>
<li><code><a title="src.twitterclient.TwitterClient.fetch_followers" href="#src.twitterclient.TwitterClient.fetch_followers">fetch_followers</a></code></li>
<li><code><a title="src.twitterclient.TwitterClient.fetch_tweets" href="#src.twitterclient.TwitterClient.fetch_tweets">fetch_tweets</a></code></li>
<li><code><a title="src.twitterclient.TwitterClient.fetch_tweets_of_followers" href="#src.twitterclient.TwitterClient.fetch_tweets_of_followers">fetch_tweets_of_followers</a></code></li>
<li><code><a title="src.twitterclient.TwitterClient.fetch_users" href="#src.twitterclient.TwitterClient.fetch_users">fetch_users</a></code></li>
<li><code><a title="src.twitterclient.TwitterClient.lookup_user" href="#src.twitterclient.TwitterClient.lookup_user">lookup_user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>