<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.sentimentanalysis API documentation</title>
<meta name="description" content="Sentimentanalysis module for deriving the Sentiment - particularly the Polarity - of each tweet." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.sentimentanalysis</code></h1>
</header>
<section id="section-intro">
<p>Sentimentanalysis module for deriving the Sentiment - particularly the Polarity - of each tweet.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Sentimentanalysis module for deriving the Sentiment - particularly the Polarity - of each tweet.
&#34;&#34;&#34;
import textblob
import numpy as np
import re
import numpy as np
from PIL import Image
import os
import matplotlib.pyplot as plt
from wordcloud import WordCloud, STOPWORDS
import src.constants as const


class SentimentAnalysis:
    &#34;&#34;&#34;
    This class is responsible for the Sentiment Analysis part with textblob. By initialization it will get a list of
    tweets (only tweet_text) handed over.

    Parameters
    ----------
    tweets : list
        list of tweets

    Attributes
    ----------
    tweets : list
    polarity_list : list
    avg_polarity : double
    avg_polarity_meaning : str
    &#34;&#34;&#34;

    def __init__(self, tweets):
        &#34;&#34;&#34;
        Constructor of SentimentAnalysis.
        &#34;&#34;&#34;
        # list of tweets_text
        self.tweets = tweets
        # polarity list of analysed tweets
        self.polarity_list = []
        # store avg_sentiment
        self.avg_polarity = None
        self.avg_polarity_meaning = None

    def _clean_tweet(self, tweet) -&gt; str:
        &#34;&#34;&#34;
        Utility function to clean tweet text by removing links, special characters using regex statements.

        Parameters
        ----------
        tweet : str
            Provide Tweet text to clean.

        Returns
        -------
        str: cleaned tweet.
        &#34;&#34;&#34;
        return &#34; &#34;.join(
            re.sub(
                &#34;(@[A-Za-z0-9]+)|([^0-9A-Za-z \t])|(\w+:\/\/\S+)&#34;, &#34; &#34;, tweet
            ).split()
        )

    def analyse_all_tweets(self) -&gt; list:
        &#34;&#34;&#34;
        analysing all tweets and get average polarity as output.

        Returns
        -------
        polarity_list : list
            Returns list of the polarity of each tweet.
        &#34;&#34;&#34;
        for eachtweet in self.tweets:
            cleaned_tweet = self._clean_tweet(eachtweet)
            analysis = textblob.TextBlob(cleaned_tweet)
            self.polarity_list.append(analysis.sentiment.polarity)
        return self.polarity_list

    def get_avg_polarity(self) -&gt; dict:
        &#34;&#34;&#34;
        After analysing all tweets and writing a polarity row to the dataframe (and to the csv) calculate the avg_polarity and get its textual meaning.

        Returns
        -------
        tuple: Returns tuple of avg_polarity and avg_polarity_meaning.
        &#34;&#34;&#34;
        if len(self.polarity_list) == 0:
            self.analyse_all_tweets()
        if self.avg_polarity is None or self.avg_polarity_meaning is None:
            self.avg_polarity = np.mean(self.polarity_list)
            self.avg_polarity_meaning = self.get_polarity_meaning(self.avg_polarity)

        return {
            &#34;avg_polarity&#34;: self.avg_polarity,
            &#34;avg_polarity_meaning&#34;: self.avg_polarity_meaning,
        }

    def analyse_single_tweet(self, index) -&gt; str:
        &#34;&#34;&#34;
        Analyse polarity of single tweet.

        Parameters
        ----------
        index : int
            Index of the entry in the DataFrame tweets_df.

        Returns
        -------
        str: polarity meaning of the analyzed tweet.
        &#34;&#34;&#34;
        tweet_text = self.tweets[index]
        cleaned_tweet_text = self._clean_tweet(tweet_text)
        analysis = textblob.TextBlob(cleaned_tweet_text)
        return self.get_polarity_meaning(analysis.sentiment.polarity)

    def get_polarity_meaning(self, polarity) -&gt; str:
        &#34;&#34;&#34;
        Translate polarity values from -1 to 1 in textual output/meaning.

        Parameters
        ----------
        polarity : double
            Value from -1 to 1 representing the polarity.

        Returns
        -------
        polarity_list : list
            Returns list of the polarity of each tweet.
        &#34;&#34;&#34;
        if polarity &gt; 0.8:
            return &#34;extremely positive&#34;
        elif polarity &gt; 0.3:
            return &#34;positive&#34;
        elif polarity &gt; 0.05 and polarity &lt;= 0.3:
            return &#34;slightly positive&#34;
        elif polarity &lt;= 0.05 or polarity &gt;= -0.05:
            return &#34;neutral&#34;
        elif polarity &lt; -0.05 and polarity &lt;= -0.03:
            return &#34;slightly negative&#34;
        elif polarity &lt; -0.3 and polarity &lt;= -0.8:
            return &#34;negative&#34;
        elif polarity &lt; -0.8:
            return &#34;extremely negative&#34;
        else:
            return &#34;error!&#34;

    def get_most_used_words(self, querystring):
        &#34;&#34;&#34;
        Get most used words of all tweets and make a wordcloud with the mask of the official twitterlogo.

        Parameters
        ----------
        querystring : str
            For saving the generated wordcloud png file to the correct directory path.
        &#34;&#34;&#34;
        # combine all tweets text to one string
        all_tweets_text = self._clean_tweet(&#34; &#34;.join(self.tweets))
        # get current working directory
        d = os.path.dirname(__file__) if &#34;__file__&#34; in locals() else os.getcwd()
        # take official twitter logo as mask
        twitter_mask = np.array(
            Image.open(os.path.join(d, &#34;wordcloud/masks/twitterlogo.png&#34;))
        )
        # generate wordcloud
        wc = WordCloud(
            background_color=&#34;white&#34;,
            max_words=30,
            mask=twitter_mask,
            stopwords=STOPWORDS,
            contour_width=3,
        ).generate(all_tweets_text)
        # store to file
        wc.to_file(os.path.join(d, f&#34;fetched/{querystring}/10MostUsedWords_wc.png&#34;))
        print(
            f&#34;10MostUsedWords Wordcloud is stored at &#39;fetched/{querystring}/10MostUsedWords_wc.png&#39;.&#34;
        )
        # show
        plt.imshow(wc, interpolation=&#34;bilinear&#34;)
        plt.axis(&#34;off&#34;)
        plt.figure()
        plt.imshow(twitter_mask, cmap=plt.cm.gray, interpolation=&#34;bilinear&#34;)
        plt.axis(&#34;off&#34;)
        plt.show()
        # img = Image.open(&#34;wordcloud/generated/twitterlogo_wc.png&#34;)
        # img.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.sentimentanalysis.SentimentAnalysis"><code class="flex name class">
<span>class <span class="ident">SentimentAnalysis</span></span>
<span>(</span><span>tweets)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is responsible for the Sentiment Analysis part with textblob. By initialization it will get a list of
tweets (only tweet_text) handed over.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tweets</code></strong> :&ensp;<code>list</code></dt>
<dd>list of tweets</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>tweets</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>polarity_list</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>avg_polarity</code></strong> :&ensp;<code>double</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>avg_polarity_meaning</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Constructor of SentimentAnalysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SentimentAnalysis:
    &#34;&#34;&#34;
    This class is responsible for the Sentiment Analysis part with textblob. By initialization it will get a list of
    tweets (only tweet_text) handed over.

    Parameters
    ----------
    tweets : list
        list of tweets

    Attributes
    ----------
    tweets : list
    polarity_list : list
    avg_polarity : double
    avg_polarity_meaning : str
    &#34;&#34;&#34;

    def __init__(self, tweets):
        &#34;&#34;&#34;
        Constructor of SentimentAnalysis.
        &#34;&#34;&#34;
        # list of tweets_text
        self.tweets = tweets
        # polarity list of analysed tweets
        self.polarity_list = []
        # store avg_sentiment
        self.avg_polarity = None
        self.avg_polarity_meaning = None

    def _clean_tweet(self, tweet) -&gt; str:
        &#34;&#34;&#34;
        Utility function to clean tweet text by removing links, special characters using regex statements.

        Parameters
        ----------
        tweet : str
            Provide Tweet text to clean.

        Returns
        -------
        str: cleaned tweet.
        &#34;&#34;&#34;
        return &#34; &#34;.join(
            re.sub(
                &#34;(@[A-Za-z0-9]+)|([^0-9A-Za-z \t])|(\w+:\/\/\S+)&#34;, &#34; &#34;, tweet
            ).split()
        )

    def analyse_all_tweets(self) -&gt; list:
        &#34;&#34;&#34;
        analysing all tweets and get average polarity as output.

        Returns
        -------
        polarity_list : list
            Returns list of the polarity of each tweet.
        &#34;&#34;&#34;
        for eachtweet in self.tweets:
            cleaned_tweet = self._clean_tweet(eachtweet)
            analysis = textblob.TextBlob(cleaned_tweet)
            self.polarity_list.append(analysis.sentiment.polarity)
        return self.polarity_list

    def get_avg_polarity(self) -&gt; dict:
        &#34;&#34;&#34;
        After analysing all tweets and writing a polarity row to the dataframe (and to the csv) calculate the avg_polarity and get its textual meaning.

        Returns
        -------
        tuple: Returns tuple of avg_polarity and avg_polarity_meaning.
        &#34;&#34;&#34;
        if len(self.polarity_list) == 0:
            self.analyse_all_tweets()
        if self.avg_polarity is None or self.avg_polarity_meaning is None:
            self.avg_polarity = np.mean(self.polarity_list)
            self.avg_polarity_meaning = self.get_polarity_meaning(self.avg_polarity)

        return {
            &#34;avg_polarity&#34;: self.avg_polarity,
            &#34;avg_polarity_meaning&#34;: self.avg_polarity_meaning,
        }

    def analyse_single_tweet(self, index) -&gt; str:
        &#34;&#34;&#34;
        Analyse polarity of single tweet.

        Parameters
        ----------
        index : int
            Index of the entry in the DataFrame tweets_df.

        Returns
        -------
        str: polarity meaning of the analyzed tweet.
        &#34;&#34;&#34;
        tweet_text = self.tweets[index]
        cleaned_tweet_text = self._clean_tweet(tweet_text)
        analysis = textblob.TextBlob(cleaned_tweet_text)
        return self.get_polarity_meaning(analysis.sentiment.polarity)

    def get_polarity_meaning(self, polarity) -&gt; str:
        &#34;&#34;&#34;
        Translate polarity values from -1 to 1 in textual output/meaning.

        Parameters
        ----------
        polarity : double
            Value from -1 to 1 representing the polarity.

        Returns
        -------
        polarity_list : list
            Returns list of the polarity of each tweet.
        &#34;&#34;&#34;
        if polarity &gt; 0.8:
            return &#34;extremely positive&#34;
        elif polarity &gt; 0.3:
            return &#34;positive&#34;
        elif polarity &gt; 0.05 and polarity &lt;= 0.3:
            return &#34;slightly positive&#34;
        elif polarity &lt;= 0.05 or polarity &gt;= -0.05:
            return &#34;neutral&#34;
        elif polarity &lt; -0.05 and polarity &lt;= -0.03:
            return &#34;slightly negative&#34;
        elif polarity &lt; -0.3 and polarity &lt;= -0.8:
            return &#34;negative&#34;
        elif polarity &lt; -0.8:
            return &#34;extremely negative&#34;
        else:
            return &#34;error!&#34;

    def get_most_used_words(self, querystring):
        &#34;&#34;&#34;
        Get most used words of all tweets and make a wordcloud with the mask of the official twitterlogo.

        Parameters
        ----------
        querystring : str
            For saving the generated wordcloud png file to the correct directory path.
        &#34;&#34;&#34;
        # combine all tweets text to one string
        all_tweets_text = self._clean_tweet(&#34; &#34;.join(self.tweets))
        # get current working directory
        d = os.path.dirname(__file__) if &#34;__file__&#34; in locals() else os.getcwd()
        # take official twitter logo as mask
        twitter_mask = np.array(
            Image.open(os.path.join(d, &#34;wordcloud/masks/twitterlogo.png&#34;))
        )
        # generate wordcloud
        wc = WordCloud(
            background_color=&#34;white&#34;,
            max_words=30,
            mask=twitter_mask,
            stopwords=STOPWORDS,
            contour_width=3,
        ).generate(all_tweets_text)
        # store to file
        wc.to_file(os.path.join(d, f&#34;fetched/{querystring}/10MostUsedWords_wc.png&#34;))
        print(
            f&#34;10MostUsedWords Wordcloud is stored at &#39;fetched/{querystring}/10MostUsedWords_wc.png&#39;.&#34;
        )
        # show
        plt.imshow(wc, interpolation=&#34;bilinear&#34;)
        plt.axis(&#34;off&#34;)
        plt.figure()
        plt.imshow(twitter_mask, cmap=plt.cm.gray, interpolation=&#34;bilinear&#34;)
        plt.axis(&#34;off&#34;)
        plt.show()
        # img = Image.open(&#34;wordcloud/generated/twitterlogo_wc.png&#34;)
        # img.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.sentimentanalysis.SentimentAnalysis.analyse_all_tweets"><code class="name flex">
<span>def <span class="ident">analyse_all_tweets</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>analysing all tweets and get average polarity as output.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>polarity_list</code></strong> :&ensp;<code>list</code></dt>
<dd>Returns list of the polarity of each tweet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyse_all_tweets(self) -&gt; list:
    &#34;&#34;&#34;
    analysing all tweets and get average polarity as output.

    Returns
    -------
    polarity_list : list
        Returns list of the polarity of each tweet.
    &#34;&#34;&#34;
    for eachtweet in self.tweets:
        cleaned_tweet = self._clean_tweet(eachtweet)
        analysis = textblob.TextBlob(cleaned_tweet)
        self.polarity_list.append(analysis.sentiment.polarity)
    return self.polarity_list</code></pre>
</details>
</dd>
<dt id="src.sentimentanalysis.SentimentAnalysis.analyse_single_tweet"><code class="name flex">
<span>def <span class="ident">analyse_single_tweet</span></span>(<span>self, index) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Analyse polarity of single tweet.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the entry in the DataFrame tweets_df.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>str: polarity meaning of the analyzed tweet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyse_single_tweet(self, index) -&gt; str:
    &#34;&#34;&#34;
    Analyse polarity of single tweet.

    Parameters
    ----------
    index : int
        Index of the entry in the DataFrame tweets_df.

    Returns
    -------
    str: polarity meaning of the analyzed tweet.
    &#34;&#34;&#34;
    tweet_text = self.tweets[index]
    cleaned_tweet_text = self._clean_tweet(tweet_text)
    analysis = textblob.TextBlob(cleaned_tweet_text)
    return self.get_polarity_meaning(analysis.sentiment.polarity)</code></pre>
</details>
</dd>
<dt id="src.sentimentanalysis.SentimentAnalysis.get_avg_polarity"><code class="name flex">
<span>def <span class="ident">get_avg_polarity</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>After analysing all tweets and writing a polarity row to the dataframe (and to the csv) calculate the avg_polarity and get its textual meaning.</p>
<h2 id="returns">Returns</h2>
<p>tuple: Returns tuple of avg_polarity and avg_polarity_meaning.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_avg_polarity(self) -&gt; dict:
    &#34;&#34;&#34;
    After analysing all tweets and writing a polarity row to the dataframe (and to the csv) calculate the avg_polarity and get its textual meaning.

    Returns
    -------
    tuple: Returns tuple of avg_polarity and avg_polarity_meaning.
    &#34;&#34;&#34;
    if len(self.polarity_list) == 0:
        self.analyse_all_tweets()
    if self.avg_polarity is None or self.avg_polarity_meaning is None:
        self.avg_polarity = np.mean(self.polarity_list)
        self.avg_polarity_meaning = self.get_polarity_meaning(self.avg_polarity)

    return {
        &#34;avg_polarity&#34;: self.avg_polarity,
        &#34;avg_polarity_meaning&#34;: self.avg_polarity_meaning,
    }</code></pre>
</details>
</dd>
<dt id="src.sentimentanalysis.SentimentAnalysis.get_most_used_words"><code class="name flex">
<span>def <span class="ident">get_most_used_words</span></span>(<span>self, querystring)</span>
</code></dt>
<dd>
<div class="desc"><p>Get most used words of all tweets and make a wordcloud with the mask of the official twitterlogo.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>querystring</code></strong> :&ensp;<code>str</code></dt>
<dd>For saving the generated wordcloud png file to the correct directory path.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_most_used_words(self, querystring):
    &#34;&#34;&#34;
    Get most used words of all tweets and make a wordcloud with the mask of the official twitterlogo.

    Parameters
    ----------
    querystring : str
        For saving the generated wordcloud png file to the correct directory path.
    &#34;&#34;&#34;
    # combine all tweets text to one string
    all_tweets_text = self._clean_tweet(&#34; &#34;.join(self.tweets))
    # get current working directory
    d = os.path.dirname(__file__) if &#34;__file__&#34; in locals() else os.getcwd()
    # take official twitter logo as mask
    twitter_mask = np.array(
        Image.open(os.path.join(d, &#34;wordcloud/masks/twitterlogo.png&#34;))
    )
    # generate wordcloud
    wc = WordCloud(
        background_color=&#34;white&#34;,
        max_words=30,
        mask=twitter_mask,
        stopwords=STOPWORDS,
        contour_width=3,
    ).generate(all_tweets_text)
    # store to file
    wc.to_file(os.path.join(d, f&#34;fetched/{querystring}/10MostUsedWords_wc.png&#34;))
    print(
        f&#34;10MostUsedWords Wordcloud is stored at &#39;fetched/{querystring}/10MostUsedWords_wc.png&#39;.&#34;
    )
    # show
    plt.imshow(wc, interpolation=&#34;bilinear&#34;)
    plt.axis(&#34;off&#34;)
    plt.figure()
    plt.imshow(twitter_mask, cmap=plt.cm.gray, interpolation=&#34;bilinear&#34;)
    plt.axis(&#34;off&#34;)
    plt.show()
    # img = Image.open(&#34;wordcloud/generated/twitterlogo_wc.png&#34;)
    # img.show()</code></pre>
</details>
</dd>
<dt id="src.sentimentanalysis.SentimentAnalysis.get_polarity_meaning"><code class="name flex">
<span>def <span class="ident">get_polarity_meaning</span></span>(<span>self, polarity) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Translate polarity values from -1 to 1 in textual output/meaning.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>polarity</code></strong> :&ensp;<code>double</code></dt>
<dd>Value from -1 to 1 representing the polarity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>polarity_list</code></strong> :&ensp;<code>list</code></dt>
<dd>Returns list of the polarity of each tweet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_polarity_meaning(self, polarity) -&gt; str:
    &#34;&#34;&#34;
    Translate polarity values from -1 to 1 in textual output/meaning.

    Parameters
    ----------
    polarity : double
        Value from -1 to 1 representing the polarity.

    Returns
    -------
    polarity_list : list
        Returns list of the polarity of each tweet.
    &#34;&#34;&#34;
    if polarity &gt; 0.8:
        return &#34;extremely positive&#34;
    elif polarity &gt; 0.3:
        return &#34;positive&#34;
    elif polarity &gt; 0.05 and polarity &lt;= 0.3:
        return &#34;slightly positive&#34;
    elif polarity &lt;= 0.05 or polarity &gt;= -0.05:
        return &#34;neutral&#34;
    elif polarity &lt; -0.05 and polarity &lt;= -0.03:
        return &#34;slightly negative&#34;
    elif polarity &lt; -0.3 and polarity &lt;= -0.8:
        return &#34;negative&#34;
    elif polarity &lt; -0.8:
        return &#34;extremely negative&#34;
    else:
        return &#34;error!&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.sentimentanalysis.SentimentAnalysis" href="#src.sentimentanalysis.SentimentAnalysis">SentimentAnalysis</a></code></h4>
<ul class="">
<li><code><a title="src.sentimentanalysis.SentimentAnalysis.analyse_all_tweets" href="#src.sentimentanalysis.SentimentAnalysis.analyse_all_tweets">analyse_all_tweets</a></code></li>
<li><code><a title="src.sentimentanalysis.SentimentAnalysis.analyse_single_tweet" href="#src.sentimentanalysis.SentimentAnalysis.analyse_single_tweet">analyse_single_tweet</a></code></li>
<li><code><a title="src.sentimentanalysis.SentimentAnalysis.get_avg_polarity" href="#src.sentimentanalysis.SentimentAnalysis.get_avg_polarity">get_avg_polarity</a></code></li>
<li><code><a title="src.sentimentanalysis.SentimentAnalysis.get_most_used_words" href="#src.sentimentanalysis.SentimentAnalysis.get_most_used_words">get_most_used_words</a></code></li>
<li><code><a title="src.sentimentanalysis.SentimentAnalysis.get_polarity_meaning" href="#src.sentimentanalysis.SentimentAnalysis.get_polarity_meaning">get_polarity_meaning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>